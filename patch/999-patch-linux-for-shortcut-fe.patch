diff --git a/./target/linux/generic/patches-4.4/999-shortcut-fe.patch b/./target/linux/generic/patches-4.4/999-shortcut-fe.patch
new file mode 100644
index 0000000..1f6451c
--- /dev/null
+++ b/./target/linux/generic/patches-4.4/999-shortcut-fe.patch
@@ -0,0 +1,64 @@
+
+--- a/net/core/dev.c	2017-06-22 17:51:57.000000000 +0800
++++ b/net/core/dev.c	2017-06-22 18:06:31.388426964 +0800
+@@ -3801,6 +3801,8 @@ int netdev_rx_handler_register(struct ne
+ }
+ EXPORT_SYMBOL_GPL(netdev_rx_handler_register);
+ 
++int (*athrs_fast_nat_recv)(struct sk_buff *skb) __rcu __read_mostly;
++EXPORT_SYMBOL_GPL(athrs_fast_nat_recv);
+ /**
+  *	netdev_rx_handler_unregister - unregister receive handler
+  *	@dev: device to unregister a handler from
+@@ -3865,6 +3867,7 @@ static int __netif_receive_skb_core(stru
+ 	bool deliver_exact = false;
+ 	int ret = NET_RX_DROP;
+ 	__be16 type;
++	int (*fast_recv)(struct sk_buff *skb);
+ 
+ 	net_timestamp_check(!netdev_tstamp_prequeue, skb);
+ 
+@@ -3877,6 +3880,14 @@ static int __netif_receive_skb_core(stru
+ 		skb_reset_transport_header(skb);
+ 	skb_reset_mac_len(skb);
+ 
++	fast_recv = rcu_dereference(athrs_fast_nat_recv);
++	if (fast_recv) {
++		if (fast_recv(skb)) {
++			rcu_read_unlock();
++			return NET_RX_SUCCESS;
++		}
++	}
++
+ 	pt_prev = NULL;
+ 
+ another_round:
+--- a/net/netfilter/nf_conntrack_proto_tcp.c	2017-06-22 17:51:57.000000000 +0800
++++ a/net/netfilter/nf_conntrack_proto_tcp.c	2017-06-22 18:11:54.340560193 +0800
+@@ -34,12 +34,14 @@
+ #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+ 
+ /* Do not check the TCP window for incoming packets  */
+-static int nf_ct_tcp_no_window_check __read_mostly = 1;
++int nf_ct_tcp_no_window_check __read_mostly = 0;
++EXPORT_SYMBOL_GPL(nf_ct_tcp_no_window_check);;
+ 
+ /* "Be conservative in what you do,
+     be liberal in what you accept from others."
+     If it's non-zero, we mark only out of window RST segments as INVALID. */
+-static int nf_ct_tcp_be_liberal __read_mostly = 0;
++int nf_ct_tcp_be_liberal __read_mostly = 0;
++EXPORT_SYMBOL_GPL(nf_ct_tcp_be_liberal);
+ 
+ /* If it is set to zero, we disable picking up already established
+    connections. */
+--- a/include/linux/skbuff.h	2017-06-22 17:51:57.000000000 +0800
++++ b/include/linux/skbuff.h	2017-06-22 18:36:56.399951434 +0800
+@@ -630,6 +630,7 @@ struct sk_buff {
+ 	__u8			no_fcs:1;
+ 	/* Indicates the inner headers are valid in the skbuff. */
+ 	__u8			encapsulation:1;
++	__u8			fast_forwarded:1;
+ 	__u8			encap_hdr_csum:1;
+ 	__u8			csum_valid:1;
+ 	__u8			csum_complete_sw:1;
